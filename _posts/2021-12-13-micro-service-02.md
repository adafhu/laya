---
layout:     post
title:      "Go Macro Service 02"
subtitle:   "微服务设计"
date:       2021-12-13 09:56:07
author:     "kgzhang"
catalog: false
category: golang
header-style: text
tags:
  - golang
---

## Catalog
- API Gateway
- BFF: Backend For Frontend
- API Gateway 与 BFF 的演进过程
- 微服务的拆分
    - 按照垂直功能拆分
    - CQRS: 从性能角度去拆分
    - 统一接入：底层微服务上封装一层代理
    - DDD 业务领域：抽象出创作者模型
- 微服务安全

## API Gateway

### API Gateway 的演进

#### 阶段一、微服务直接对外暴露接口
> 负载均衡组件：SLB、ELB

弊端1：用户流量经负载均衡组件，直接将请求转发到对应的微服务。

客户端与微服务强耦合，导致微服务升级后，不能下掉老的版本。多版本共存，增大微服务的复杂性。

弊端2：各端需要多次请求，客户端聚合数据，工作量大，延迟高。

打开一个页面往往要调用多个微服务的接口，如果都让客户端去请求聚合这些数据，客户端的工作量就会很大。此外请求多接口的数据还需要考虑超时、失败等问题，进一步加剧了客户端的复杂度。

弊端3：协议不统一，需要客户端来兼容。

协议不统一是指各微服务定义的 API 协议不一致，如业务状态码、HTTP 请求方式等，这样客户端需要写多套代码去封装兼容。

弊端4：多终端兼容逻辑复杂，每个服务都要处理。

因为微服务直接对外提供服务，所以微服务需要兼容多终端如不同的机型、不同的网络 3G、4G 等。

弊端5：统一逻辑无法收敛，比如安全认证、限流。

统一逻辑无法收敛，直白讲就是无法复用已有的功能。

对外暴露的表面积越少，程序就越健壮。

#### 阶段二、app-interface BFF 层

> BFF 层：Backend For Frontend

后端 API 接口是按照 Restful API 划分的，是面向资源的。后台同学可能觉得这样做很脏。

但是这不符合业务需求，业务需要的是聚合接口，打开网站首页需要访问用户账号、充值计费、视频、稿件等多个微服务。

所以，api-interface 就按照业务形态对这些微服务的接口做了 dataset join，这样在理想的情况下可以使得用户端打开首页只需要发一个请求。接口是面向业务场景的。

也就是把阶段一中需要客户度聚合的微服务接口剥离出来，做成一个单独的服务，BFF 层。

BFF 的优越性：
- 轻量交互: 协议精简、聚合。微服务层使用 RPC 提供粗粒度（批形式）的接口给 BFF，BFF 根据用户提供个性化的接口。比如如果是用户端是移动端流量环境，那就少提供一些数据以便更快地响应，节省用户资源。
- 差异服务：数据裁剪以及聚合，针对终端定制化 API。比如请求一张图片，微服务会把这张图的清晰版、高清版和更高清版的地址都提供给 BFF。BFF 根据用户端做针对化的处理，比如电视终端、4G网络或 IPad ... 以前这些逻辑都是散落在微服务里的，现在可以把他们集中到微服务层。
- 动态升级：把版本兼容性的事情推给了 BFF，微服务就可以自己去升级了。之前微服务升级自己要同时确保版本兼容和新增逻辑，所以工作量大；现在微服务只需要自己升级服务，版本兼容的事情由BFF 层控制，这样的话专业的事情交给专业的人做，就降低了系统复杂度。
- 沟通效率提升：协作模式演进为移动业务+网关小组。固定地由业务和网关的人去对接，他们之间磨合之后效率会提升。

#### app-interface 的缺陷

**app-interface 容易形成单点故障**，这里的单点并不是说 app-interface 是单实例服务，而是 app-interface 是所有微服务的出口，它一旦出现故障会造成全局服务不可用。

app-interface 的业务复杂度越来越高。对接不同微服务的成本没有消失，在阶段一这些成本是用户端负责，阶段二 app-interface 这些成本是由 app-interface 负责。

解决方案：分而治之，再次拆分。按照用户场景和重要性，将原来单一的 BFF 拆分成多个，再次拆分成账号体系、播放等。

跨横切面逻辑：安全认证、日志监控、限流熔断等，需要统一。最初的 BFF 是业务接口的聚合加上横切面逻辑的聚合。随着 BFF 规模的扩大，BFF 拆分成多个 BFF 模块，并且把横切面逻辑剥离出去形成网关 API Gateway。

API Gateway 变成了一个基础设施。

#### API Gateway

**此时业务流量实际为:**

移动端 -> CDN/SLB (这层是免不了的) -> API Gateway -> BFF -> Microservice

所以 API Gateway 是用来做日志、鉴权等横切面操作的。

## Mircoservice 划分

### 划分依据
- 部门职能
- DDD 划分
- CQRS: command and Query，命令端和查询端。命令端负责数据变更，查询端只负责读。

### 不同划分阶段的演进

**按职能划分到按 DDD 划分**

一开始 B 站的创作分为稿件和视频，对应各自的部分。后来逐渐演进出了创作端, 对应 DDD 领域模型。

微服务的划分也是 “分久必合合久必分”。比如用户信息包含 VIP、积分等信息，最初时把它们都化为单独的服务。结果发现会导致扇出的非常厉害（前端1个请求需要多个微服务响应）。

此时就需要搞一个用户中心的服务把这些服务集成起来；或者底层仍然维持这样的微服务，在这些服务的上层封装一个用户服务。这个用户服务暴露有限的 API 接口给 BFF。

**CQRS 划分**

```
创作者的稿件 --> archive mysql --> cannel --> kafka --> 稿件 job --> archive-result-mysql <-- 稿件结果 <-- 客户端
```

创作者的稿件写入 archive mysql, mysql 内的结果会通过 cannel 推送到 kafka，稿件 job 服务是一个审核机制，决定了稿件是否能公共展示。可以公共展示的写入 archive-result-mysql 中，query 程序从 archive-result-mysql 中读取可以公开展示的稿件。

中间件 cannel 的选型：
- 对于将 archive-mysql 的信息同步到 archive-result-mysql 中，最简单的方式就是定时轮询，也就是 pull。这种的弊端在于延迟性或给 mysql 的压力大。
- cannel 是一个 push 模型，它伪装成了 mysql 的 slaver, 所以能够订阅 mysql binlog 的变更信息。

### 划分微服务的几种架构模型
- account-service: 在底层的用户微服务上加一层代理。对内网的 API 组合器。
- BFF: 对公网的 API 组合器。
- CQRS: 按照读写进行划分。
- 按照垂直业务领域
- 按照 DDD 业务领域

## Microservice 安全

安全：内网安全和外网安全。

Microservice 安全认证流程：
- 用户填入账号密码，登录成功后，会颁发一个 token。
- 用户端后续的请求都会携带此 token。
- Api Gateway OAthun 鉴权：认证此 token，Api Gateway 认证成功后会得到用户 ID，拦截此请求，把用户 ID 放到 RPC metadata 或 Http 的 header 里面。为了安全起见，Api Gateway 还会检查用户端的请求，如果请求头里已经有代表 userID 的字段还会把它去除，以防止恶意注入。
- Header 头：BFF 层拿到用户 ID 后，调用下游的微服务。
- 传参：下游的微服务会在 RPC 定义里就可以把用户 ID 作为参数了。

内网安全重要的是 RBAC：Role-Based Access Control 基于角色的访问控制。开源框架如：Apache Shiro
- 身份认证：服务的调用方是谁, authentication，认证。实现方式：颁发 token/证书
- 授权：明确调用方的角色后，它能调用哪些API：authorization，授权
- 更严格：使用 https 进行加密传输

网络环境区分：
- Full Trust, +完全信任
- Half Trust, +进行身份认证
- Zero Trust，+传输加密
