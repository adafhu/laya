---
layout:     post
title:      "Live2:"
subtitle:   ""
date:       2021-12-12 19:57:22
author:     "kgzhang"
catalog: false
category: golang
header-style: text
tags:
  - golang
---

## 开源演进趋势
朝着高并发的演进。但是中小型企业并不需要高并发，他们更需要快速高效开发的工具。

## 答疑
1、
- 加 transationID, 一条 SQL 一个 Log
- 缓存一下,
- AOP 对代码无入侵性

4、微服务是如何保证性能的？

单体应用模块化做好，单体应用性能肯定好。

拆分微服务是为了控制复杂度，牺牲的性能，因为增加了很多 IO 开销。

如何保证整体性能：高性能的网络库，尽量避免发起多次微服务调用，尽量缓存。

序列化协议：proto 不要用文本。

5、

有一个临界点：控制不住复杂度了。

模块化有了封装，通信不再是任意的，简化了模块之间的复杂度。

本质是模块和封装。本质还是分而治之。

开发微服务：启动一个开发环境，开发 A 时访问开发环境的 B。很少在本地启动多个服务。不可能在本地启动所有的微服务。

- 确定 API 大概的格式。
- B 服务部署一个 mock 的实例供我调用。
- 双方开发完成后，办公网络内 A 服务与 B 服务联合调试。（中间件要支持 IP 直连）
- 部署到测试环境，请 QA 测试

微服务更易测试是指微服务模块更加容易测试。单独地测试一个单独的模块。

6、

系统规模大时，独立的数据库是必要的。

大厂不推荐 join。应用层去 join。

- 查询是无状态的。
- 数据库经常是瓶颈，把压力分散到应用层上。
- 分库分表。支持 join 查询的中间件：一条 SQL 会膨胀成很多条子查询。

7、版本管理

忽然想到一个问题，微服务提供的接口会不会有版本管理？如果有版本管理是不是也类似于 /api/v1、 /api/v2、/api/v3 这样的方式进行管理 ？

dubbo 是自带版本的。

逼不得已不要维护多个版本。

## 七层负载均衡和四层负载均衡
- 七层：应用层负载均衡。在第七层我们能获取应用信息。比如使用 Nginx 根据请求路径分发到不同服务器，或者解析 Header
- 四层: 改写源地址和端口
 - 关键在于 IP + 端口。改写地址
 - 隧道模式。
 - ：Mac 地址转发。
- 二层：
- 三层：IP 转发。可以理解为 VIP

## 染色
染色—— 链路构建与上下文传递

- 进程内上下文传递
- 跨进程传递。把染色数据也放到序列化协议中去。
- 跨协议传递，RPC 协议传递到 HTTP 协议。

染色究竟是怎么做的？

染色就是指源数据传递。整条链路上做一些控制手段。

使用场景？
- 压测。把请求发到要压测的数据库。
- A/B test。
- 灰度发布

## Error 
- Sentinel Error: 中间件用的比较多，要少而精。特定的，用户需要做特殊处理的错误。典型的 NoRows。不是不能用，而是慎重。
- Error types: 中间件常用，定义自身的错误规范。但是不要把这个 Error 作为 public 的。
- Opaque errors: 不透明错误。用户只能访问行为，error 不暴露出去。

不要暴露包的公共变量。

错误处理：
- 正常流程代码，将成为一条直线。

错误处理补充原则：
- 公开方法，永远加一个 error 作为返回值，即使当下你觉得不需要返回 error 也要加上一个。反例：不返回错误，错误时 panic。结果有的服务不能 panic。解决手段开了一个新的接口。
- 如果方法返回来额 error，永远要记得处理。
- 逼不得已不要忽略错误，不要使用 `_` 吞掉。
- 遇事不决用 error。error 与 panic 之间的选择。

遇事不决用 指针，结构体与指针的选择。但是指针容易造成内存逃逸。

## 作业
- 业务方不要判断 sql.NotFound 库，而是依赖我的 DAO 错误。

业务处理：

```golang
// 使用 errors.Is
```

kratos 中的实现：
- error types
- Opaque errors

把 error 定义成私有的，然后让用户调用方法来判断错误。

## 设计一个错误系统
- 设计一个错误码规范
- 错误码分配
- 错误码转换
- 错误码 cause 处理
- 错误码记录：logging，tracing，metric
- 细节补充

### 错误码规范
- 全局唯一（看业务的规模）
- 区分错误类型
    - 输入错误还是内部错误, 输入错误就不用 debug 了
    - A 模块还是 B 模块

### 错误码规范
- family: 错误族或大类：组表示事情的轻重缓急。
    - 1 位
    - 根据需要设计自己的族。
- application 和 module：核心是为了快速 debug。
    - 规模小的话可以只保留一个
- biz code: 具体错误的原因。

设计保留段，全部范围内，具有特殊含义的错误码。

注意，数量要少。比如用 0 表示成功。

### 错误码分配

乞丐版1：用一个 wiki 维护，定时更新。和我设计的很像。

乞丐版2：用一个数据库，更新数据库

高级版：公司有创建项目的平台和流程，自动帮你分好一个段。

- 安全特性：提交代码时检查错误码是否超出范围。


强烈推荐：引入错误码的族

### 实践：错误码转换
- 上游转为自己的错误

### 实践：要不要引入 cause （原因）
拿到一个错误码后，能够看出 root error 在哪里。

### 实践：错误码记录

`log.Errorf(code, msg, args)`

tracing: 在 tracing 里记录下错误码。可以记录

## tracing: span
- span 长度代表耗时
- 所以 span 构成一个 open tracing.

plugin，intersatal，hook，middle：这些都是中间件。

metrics: 把错误码记录到 metrics 里。

error code 比较多是，不要放到时序数据库里去，会增大它的压力。

## 处理细节
错误离线分享：tracing、ELK、普罗米修斯

## 实践：用 HTTP 错误码还是业务错误码
不推荐：用 http code 表达业务含义

> 规范问题是个人偏好问题，而不是最佳实践。

最佳实践：不遵循就会容易出现 Bug。

同事讨论的差异，高性能还是高扩展，都是个人偏好问题。

## 多租户就是染色

## AOP

AOP：面向切面编程

Golang 使用 filter






