---
layout:     post
title:      "Macro Service 01: 微服务概览"
subtitle:   ""
date:       2021-12-12 16:09:11
author:     "kgzhang"
catalog: false
category: golang
header-style: text
tags:
  - golang
---

## 单体架构
单体应用随着业务复杂和网站访问量庞大后，开发迭代越来越不敏捷，而且容易出现故障。所以依据“分而治之” 的思想，很容易想到把服务拆分进行治理。

## SOA 与微服务
SOA: 面向服务的架构模式。

微服务是 SOA 的一种最佳实践。

## 微服务定义
微服务是依据业务把原来的单体服务拆分成多个单一职责的服务，服务之间相互隔离互不影响，服务之间使用轻量级的通信机制，可以通过 CI/CD 进行持续化部署和集成。

## 微服务的优点
微服务的优点：
- 小即是美。小的服务代码少，Bug 也少。可以持续集成。
- 单一职责。一个服务只做好一件事。
- 尽可能早地创建原型。因为服务之间是通过 API 交互的，所以我们只要定义好API，大家就可以协同开发。
- 可移植性比效率更重要。

## 微服务的特点
微服务的特点：
- 原子服务。
- 独立进程。
- 隔离部署。结合 K8S，可以是 POD 之间隔离。
- 去中心化服务治理。服务会存在热点。微服务通过服务发现地址后就可以 IP 直连，比统一走网关转发更能分散热点。

## 微服务缺点
- 基础设施的建设、复杂度高。
 - 集中式日志查看
 - 链路追踪
 - 搭建测试环境和本地开发环境时麻烦
- 微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用 RPC 或消息传递，来实现进程间通信。此外必须写代码处理消息传递速度过慢，或者服务不可用等局部失效问题。
- 单体的应用实现事务很方便。但是在微服务中实现事务是一个难点。
- 开发及测试一个基于微服务的应用也很复杂。（因为要搭建整体的环境）
- 服务模块间的依赖，应用升级要波及多个微服务。
- 对运维基础设施的挑战比较大。日志采集、性能、分布式存储、微服务治理、消息队列 ...

## 组件服务化
传统实现组件：库（library）、SDK。

微服务组件化：
- kit：微服务的基础库（框架）
- service：业务代码 + kit 依赖 + 第三方依赖(其他微服务？)
- RPC + message queue: 轻量级通讯

## 按业务组织服务
> 微服务的划分原则

按照业务闭环来构建团队，形成 “Cross Functional Team”。所以一个团队内既有前端也有后端，你既负责测试也负责运维发布。

理念 “you build it, you run it”。

职能团队变化：
- 测试提供测试平台：API 测试、回归测试和单元测试
- 运维提供平台：上线申请做成工单
- 开发负责应用的全生命周期, 自己开发、测试、上线。

Bilibili 模式：大前端 -> 网关接入 -> 业务服务 -> 平台服务 -> 基础设施(PaaS/SaaS)

## 去中心化
- 数据去中心化：每个服务独占数据库、独占 cache，不共享缓存和数据库，有利于服务的独立性，隔离相关干扰。
- 治理去中心化：所有流量密集的地方避免一个集中的地方去处理
- 技术去中心化：不和某种技术强绑定。

## 基础设施自动化
> 无自动不微服务，自动化包括测试和部署。

单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试和部署的复杂度会相应增加，必须有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。

- CICD: Gitlab + Gitlab Hooks + K8S。
- Testing: 测试环境、单元测试、API 自动化测试。
  - 多测试环境：回归测试
  - API 自动化测试带 WebUI
- 在线运行时：K8S，以及一系列 Prometheus、ELK、Control Panel
  - 所有应用上 K8S （数据库不是应用）

## 可用性和兼容性设计
> Design For Failure, 面向失败设计

微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题。
- 粗粒度的进程间通信：单体应用的 API 接口可以做的非常精细，但是在微服务下如果还是采用细粒度的 API 会引起服务之间的请求压力非常大，所以微服务提供的接口都是 `mulitGet`、`batchUpdate` 等批量式的接口。
- 粗粒度的接口会带来：网络延迟、消息格式、负载均衡和容错等

服务的兼容性
- 一旦发布服务后，因为可能会有其他服务依赖你的服务，所以需要保证服务的兼容性

API 服务设计接口的一个思路：发送时要保守，接收时要开放。
- 保守：按需要返回数据
- 开发：
  - 多版本的兼容
  - 参数的校验
  - ...


