---
layout:     post
title:      "Golang Live 05"
subtitle:   ""
date:       2022-01-02 19:59:04
author:     "kgzhang"
catalog: false
category: golang
header-style: text
tags:
  - golang
---

## 服务可用性答疑

### 负载均衡全局状态

为什么请求发到 Y 而不是 X 上？

### 负载均衡
- 算法
- 负载均衡算法在微服务下的额外约束
- 负载均衡的业务相关性：本地缓存与热点

### 负载均衡的本质
负载均衡的本质：挑选一个合适的服务器的问题。

### 相关算法
没有考虑服务器状态：
- 轮询
- 加权轮询
- 随机
- 加权随机
- 哈希

考虑服务器状态：
- 最小连接数

#### 轮询

背后的假设：
- 所有服务器的处理能力一样；
- 所有请求所需要的资源也是一样的；

为什么大多数情况下轮询的效果好？
- 请求量足够大
- 运行时间足够长

#### 加权轮询

假设：
- 用权重来标识服务器的处理能力
- 所有请求所需的资源也是一样的

#### 随机

随机类似于轮询，所以它基于轮询的假设：
- 每台服务器被随机到的概率是一样的

相比之下，轮询的效果可控性更强。但是大多数情况下，效果类似

#### 加权随机

#### 哈希
挑一个东西做哈希的值。

假设：
- 轮询的假设
- 哈希值是均匀的

#### 最小连接数

不足：
- 短时间内把所有请求都发过去同一台服务器
- 在链接复用的情况下，连接数不能很好代表服务器的负载 （请求数不等于连接数）

#### 最少活跃数

活跃数：当前正在处理的请求

### 负载均衡总结
- 要不要考虑服务器的处理能力？
    - 轮询，随机，哈希，最小连接数，最少活跃数
- 选择什么指标来表达服务器的当前负载？
    - 不关系服务器状态，是依赖于统计学
    - 选择连接数、请求数、响应时间、错误数 ...
- 是不是所有请求所需资源都是一样的？
    - 普通情况下不需要考虑（量大或长时间尺度下是均匀的）
    - 缺点：不考虑请求消耗资源的负载均衡容易出现偶发性的打包某一台机器的情况。（哈希的情况会更严重，可能会导致大商家全部都发到同一个机器上）

### 负载均衡算法在微服务下的额外约束
- 微服务框架很少设计为要获得全局信息。难点在于：
    - 本质是分布式一致性问题：采集信息并达到一致本质就是分布式问题
    - 借助于注册中心交换信息，会导致注册中心频繁地通知

### 负载均衡的业务相关性
- 业务相关性负载均衡：比如用户 ID
- 容易出现热点问题：某些请求全部落在某些服务器
- 优点：
    - 缓存命中率高
    - 缓存内存占用小

## 实践：重试的实现方案

考虑因素：
- 重试的时机

### 重试时机

重试时机对重试能否成功影响很大，重试的本质是希望下一次尝试的时候，导致本次失败的因素已经消失了。

- 立刻重试：当前的失败是因为环境引起的：网络、DB负责高
- 过一段时间重试，间隔时间：
    - 等时间间隔
    - 线性增长：考虑最大值
    - 指数退避重试：考虑最大值

大致规律：立刻重试如果失败，等几秒重试也失败

### 重试次数
必须控制重试次数。

重试次数需要和重试时机结合起来。

异步重试，等待一段时间后再次重试。

### 进程内重试
重试信息是保存在内存内，例如内存。

- 好处：享受到本地缓存，不依赖第三方组件。
- 坏处：容易丢失。

### 跨进程重试
- 将重试信息存储到某一个中间地方，允许别的实例定期执行重试。
    - 定时轮询数据库，压力比较大
- 分布式任务中心方案：在分布式任务中心注册一个任务，定时任务或重复任务
- 延时消息方案：发送一个延时消息给 MQ， MQ 到时会投递消息
    - 很多消息中间件不支持，需要2次开发

## 知识补充：链路超时的实现方案

### RPC 链路超时控制
- 起点设置链路超时时间
- RPC 客户端启动一个计时器

双端计时器：客户端和服务器都有计时器
- 时间一到，后续结果直接被丢掉

单一客户端计时：可能 goroutine 无法立即退出

服务端计时：客户端会一直等，直到拿到服务端的超时响应。（比较少见的）

中断：RPC 框架客户端在发起一个调用前，可以判断当前是否超时。


超时时间，传递的是什么？
- 传递的是剩余超时时间
- 过期时间戳：
    - 要不要考虑时钟不同步问题？不太需要考虑
    - 时间戳过程问题？

业务方超时控制


## 面试内容

保证微服务的可用性？
- 课程目录：过载保护、限流、降级
- 回到具体的子类
- 超时控制。手写 Go context 超时控制台代码
- 过载保护常用算法

类似问题？
- 服务治理

是怎么做隔离的？
- 动静分离、读写分离、轻重隔离和物理隔

- 动静分离：
- 轻重隔离：
- 物理隔离：亮点是线程池隔离。

为什么 go 不用线程池隔离？因为 goroutine 非常轻量，没太大价值池化。

热点服务的可用性？隔离是一方面。


为什么要有超时？
- 重点：超时后能不能中断接下来的动作
- 超时是期望的时间内能得到响应
- 重试和幂等

设置合理的超时时间？
- 使用 90 线或 99 线
- 新 API：做压测
- 无法压测：预估，DB sql 时间 + 下游响应时间

限流有哪些算法：
- BBR 算法，动态限流算法。
- 均匀性问题：尖峰问题。令牌、滑动窗口。

限流的阈值：
- 通过压测拿到数据
- 预估：

限流图记住

降级？
- 提供有损服务
- 服务间停掉不重要的服务

最佳实践
- 变更管理：

面试前写一份文档，完整描述微服务整一套服务。


## 服务治理的大统一模型

